<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Serializing acsets as JSON · ACSets.jl</title><meta name="title" content="Serializing acsets as JSON · ACSets.jl"/><meta property="og:title" content="Serializing acsets as JSON · ACSets.jl"/><meta property="twitter:title" content="Serializing acsets as JSON · ACSets.jl"/><meta name="description" content="Documentation for ACSets.jl."/><meta property="og:description" content="Documentation for ACSets.jl."/><meta property="twitter:description" content="Documentation for ACSets.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ACSets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">ACSets.jl</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Serializing acsets as JSON</a><ul class="internal"><li><a class="tocitem" href="#The-JSONSchema-for-Schemas"><span>The JSONSchema for Schemas</span></a></li><li><a class="tocitem" href="#Example-1:-Discrete-Dynamical-Systems"><span>Example 1: Discrete Dynamical Systems</span></a></li><li><a class="tocitem" href="#Example-2:-Labeled-DDS"><span>Example 2: Labeled DDS</span></a></li><li><a class="tocitem" href="#Example-3:-Graphs"><span>Example 3: Graphs</span></a></li><li><a class="tocitem" href="#Example-4:-Vertex-and-Edge-Labeled-Graph-Graph-Schema"><span>Example 4: Vertex and Edge Labeled Graph Graph Schema</span></a></li></ul></li><li><a class="tocitem" href="../ADTs/">Specifying acsets using Algebraic Data Types</a></li></ul></li><li><a class="tocitem" href="../../api/">Library Reference</a></li><li><a class="tocitem" href="../../ADTs/">Specification Language</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Serializing acsets as JSON</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Serializing acsets as JSON</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/ACSets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/ACSets.jl/blob/main/docs/literate/json_serialization.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Serializing-acsets-as-JSON"><a class="docs-heading-anchor" href="#Serializing-acsets-as-JSON">Serializing acsets as JSON</a><a id="Serializing-acsets-as-JSON-1"></a><a class="docs-heading-anchor-permalink" href="#Serializing-acsets-as-JSON" title="Permalink"></a></h1><p>Catlab supports the serialization of attributed C-sets (acsets) into JSON with their schemas. This functionality should allow you to interoperate with database representations in other languages by serializing both the data and the type into a network interoperability layer.</p><pre><code class="language-julia hljs">import JSON3, JSONSchema

using ACSets</code></pre><p>You can interact with the schema representation using JSON Schema with the <code>write_json_acset_schema</code> and <code>read_json_acset_schema</code> functions.</p><pre><code class="language-julia hljs">function roundtrip_json_acset_schema(schema)
  mktempdir() do dir
    path = joinpath(dir, &quot;schema.json&quot;)
    write_json_acset_schema(schema, path)
    read_json_acset_schema(path)
  end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">roundtrip_json_acset_schema (generic function with 1 method)</code></pre><h2 id="The-JSONSchema-for-Schemas"><a class="docs-heading-anchor" href="#The-JSONSchema-for-Schemas">The JSONSchema for Schemas</a><a id="The-JSONSchema-for-Schemas-1"></a><a class="docs-heading-anchor-permalink" href="#The-JSONSchema-for-Schemas" title="Permalink"></a></h2><p>The following code shows how to view the schema for storing schemas. You can see that this data is encoded in the standardized JSONSchema format, which is a generic way of representing data structures that are serialized to JSON. Notice that there are properties for Homs and Obs. The Homs have fields like name, dom, and codom. The Obs just have a name. AttrTypes are like Obs, but they store the name of the type that the attribute can have. In Julia, the Schemas are parametric in the AttrTypes so that uses can set those types at instance creation time. Attrs are the names of columns that point into the AttrTypes.</p><pre><code class="language-julia hljs">json_schema = JSONSchema.Schema(acset_schema_json_schema())
JSON3.print(json_schema, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">A JSONSchema2</code></pre><h2 id="Example-1:-Discrete-Dynamical-Systems"><a class="docs-heading-anchor" href="#Example-1:-Discrete-Dynamical-Systems">Example 1: Discrete Dynamical Systems</a><a id="Example-1:-Discrete-Dynamical-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Discrete-Dynamical-Systems" title="Permalink"></a></h2><p>Here is an example of an ACSet schema for Discrete Dynamical Systems. A DDS is just a set <code>X</code> whose elements we call states, and a function <code>next</code>, which take the current state and gives you the next state. Such systems are used to model processes that occur autonomously and are the simplest possible dynamical system.</p><pre><code class="language-julia hljs">SchDDS = BasicSchema([:X], [(:next,:X,:X)])

JSON3.print(generate_json_acset_schema(SchDDS), 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{String, Any}(&quot;version&quot; =&gt; Dict(&quot;ACSets&quot; =&gt; &quot;0.0.0&quot;, &quot;ACSetSchema&quot; =&gt; &quot;0.0.1&quot;), &quot;Ob&quot; =&gt; [Dict(&quot;name&quot; =&gt; &quot;X&quot;)], &quot;Hom&quot; =&gt; [Dict(&quot;name&quot; =&gt; &quot;next&quot;, &quot;codom&quot; =&gt; &quot;X&quot;, &quot;dom&quot; =&gt; &quot;X&quot;)], &quot;AttrType&quot; =&gt; Dict{String, String}[], &quot;Attr&quot; =&gt; Dict{String, String}[], &quot;equations&quot; =&gt; Any[])2</code></pre><p>LabeledDDS are a variation on DDS where the states can have symbolic names. In Catlab, every element of an object has to be identified by its integer row number. This comes out of a tradition in database design where every table has a natural number primary key. In mathematics, we often want to think of the state space not as a set of integers, but as an arbitrary set. In Catlab, we call that set the Labels and use a <code>label</code> attribute to implement the mapping of state numbers to state labels. This way the underlying database implementation can still be designed aroung natural number primary keys, but the user can use symbolic labels. Note also that this shows the schema inheritance. We state that a <code>SchLabeledDDS</code> inherits from <code>SchDDS</code> by adding a <code>label</code> attribute of type <code>Label</code>.</p><pre><code class="language-julia hljs">SchLabeledDDS = BasicSchema([:X], [(:next,:X,:X)],
                            [:Label], [(:label,:X,:Label)])

JSON3.print(generate_json_acset_schema(SchLabeledDDS), 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{String, Any}(&quot;version&quot; =&gt; Dict(&quot;ACSets&quot; =&gt; &quot;0.0.0&quot;, &quot;ACSetSchema&quot; =&gt; &quot;0.0.1&quot;), &quot;Ob&quot; =&gt; [Dict(&quot;name&quot; =&gt; &quot;X&quot;)], &quot;Hom&quot; =&gt; [Dict(&quot;name&quot; =&gt; &quot;next&quot;, &quot;codom&quot; =&gt; &quot;X&quot;, &quot;dom&quot; =&gt; &quot;X&quot;)], &quot;AttrType&quot; =&gt; [Dict(&quot;name&quot; =&gt; &quot;Label&quot;)], &quot;Attr&quot; =&gt; [Dict(&quot;name&quot; =&gt; &quot;label&quot;, &quot;codom&quot; =&gt; &quot;Label&quot;, &quot;dom&quot; =&gt; &quot;X&quot;)], &quot;equations&quot; =&gt; Any[])2</code></pre><h2 id="Example-2:-Labeled-DDS"><a class="docs-heading-anchor" href="#Example-2:-Labeled-DDS">Example 2: Labeled DDS</a><a id="Example-2:-Labeled-DDS-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Labeled-DDS" title="Permalink"></a></h2><p>With the LabeledDDS, we will create an instance by specifying data that fits the schema. Then we will create the JSON output to show how it is encoded. The JSON encoded schema above tells you how to read the JSON encoded data below. You can see that the <code>LabeledDDS</code> will have a set for <code>X</code> with a <code>Hom</code> for <code>next</code> and an attribute for <code>label</code>. Thus we can expect to see the JSON encoding of a single table database below:     1. The first level of JSON is keyed by the table names     2. Each Table is an array of rows     3. Each row is an object keyed by fields. This is the simplest way to put a relational database in a JSON document. It is a little redundant, because the field names are repeated for each row. But that makes it easy to emit and easy to parse. If this becomes a problem, we can upgrade to a more efficient representation by writing more sophisticated parsers. Something like https://github.com/JuliaIO/MsgPack.jl would be appropriate.</p><pre><code class="language-julia hljs">@acset_type LabeledDDS(SchLabeledDDS, index=[:next, :label])

ldds = LabeledDDS{Int}()
add_parts!(ldds, :X, 4, next=[2,3,4,1], label=[100, 101, 102, 103])
JSON3.print(generate_json_acset(ldds),2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{Symbol, Any}(:X =&gt; @NamedTuple{_id::Int64, next::Int64, label::Int64}[(_id = 1, next = 2, label = 100), (_id = 2, next = 3, label = 101), (_id = 3, next = 4, label = 102), (_id = 4, next = 1, label = 103)], :Label =&gt; @NamedTuple{_id::Int64}[])2</code></pre><h2 id="Example-3:-Graphs"><a class="docs-heading-anchor" href="#Example-3:-Graphs">Example 3: Graphs</a><a id="Example-3:-Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Graphs" title="Permalink"></a></h2><p>Relational databases are great, because they are capable of representing almost anything that can be stored on a computer. We move up to graphs, which is a nice data structure you have probably seen before. Notably, graphs have two tables, one for edges and one for vertices. These are the category theorist&#39;s graph, which means that they support multiple parallel edges and self-loops.</p><pre><code class="language-julia hljs"># Syntax available in Catlab:
# @present SchGraph(FreeSchema) begin
#   V::Ob
#   E::Ob
#   src::Hom(E,V)
#   tgt::Hom(E,V)
# end

SchGraph = BasicSchema([:V,:E], [(:src,:E,:V),(:tgt,:E,:V)])

JSON3.print(generate_json_acset_schema(SchGraph), 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{String, Any}(&quot;version&quot; =&gt; Dict(&quot;ACSets&quot; =&gt; &quot;0.0.0&quot;, &quot;ACSetSchema&quot; =&gt; &quot;0.0.1&quot;), &quot;Ob&quot; =&gt; [Dict(&quot;name&quot; =&gt; &quot;V&quot;), Dict(&quot;name&quot; =&gt; &quot;E&quot;)], &quot;Hom&quot; =&gt; [Dict(&quot;name&quot; =&gt; &quot;src&quot;, &quot;codom&quot; =&gt; &quot;V&quot;, &quot;dom&quot; =&gt; &quot;E&quot;), Dict(&quot;name&quot; =&gt; &quot;tgt&quot;, &quot;codom&quot; =&gt; &quot;V&quot;, &quot;dom&quot; =&gt; &quot;E&quot;)], &quot;AttrType&quot; =&gt; Dict{String, String}[], &quot;Attr&quot; =&gt; Dict{String, String}[], &quot;equations&quot; =&gt; Any[])2</code></pre><p>An example graph with 4 vertices and 2 edges.</p><pre><code class="language-julia hljs">@acset_type Graph(SchGraph, index=[:src, :tgt])

g = Graph()
add_parts!(g, :V, 4)
add_parts!(g, :E, 2, src=[1,2], tgt=[2,3])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1:2</code></pre><p>Note that the vertices are listed out in a somewhat silly way. They are given as a table with no columns, so they show up in the JSON as a bunch of empty objects. This is for consistency with our next example.</p><pre><code class="language-julia hljs">JSON3.print(generate_json_acset(g), 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{Symbol, Any}(:V =&gt; @NamedTuple{_id::Int64}[(_id = 1,), (_id = 2,), (_id = 3,), (_id = 4,)], :E =&gt; @NamedTuple{_id::Int64, src::Int64, tgt::Int64}[(_id = 1, src = 1, tgt = 2), (_id = 2, src = 2, tgt = 3)])2</code></pre><h2 id="Example-4:-Vertex-and-Edge-Labeled-Graph-Graph-Schema"><a class="docs-heading-anchor" href="#Example-4:-Vertex-and-Edge-Labeled-Graph-Graph-Schema">Example 4: Vertex and Edge Labeled Graph Graph Schema</a><a id="Example-4:-Vertex-and-Edge-Labeled-Graph-Graph-Schema-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-Vertex-and-Edge-Labeled-Graph-Graph-Schema" title="Permalink"></a></h2><p>You can extend schemas by adding more tables and columns. This inheritance is flattened when you serialize to JSON, but could be encoded in a future version.</p><pre><code class="language-julia hljs"># Syntax available in Catlab:
# @present SchVELabeledGraph &lt;: SchGraph begin
#    Label::AttrType
#    vlabel::Attr(V,Label)
#    elabel::Attr(E,Label)
# end

SchVELabeledGraph = BasicSchema([:V,:E], [(:src,:E,:V),(:tgt,:E,:V)],
  [:Label], [(:vlabel,:V,:Label),(:elabel,:E,:Label)])

JSON3.print(generate_json_acset_schema(SchVELabeledGraph), 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{String, Any}(&quot;version&quot; =&gt; Dict(&quot;ACSets&quot; =&gt; &quot;0.0.0&quot;, &quot;ACSetSchema&quot; =&gt; &quot;0.0.1&quot;), &quot;Ob&quot; =&gt; [Dict(&quot;name&quot; =&gt; &quot;V&quot;), Dict(&quot;name&quot; =&gt; &quot;E&quot;)], &quot;Hom&quot; =&gt; [Dict(&quot;name&quot; =&gt; &quot;src&quot;, &quot;codom&quot; =&gt; &quot;V&quot;, &quot;dom&quot; =&gt; &quot;E&quot;), Dict(&quot;name&quot; =&gt; &quot;tgt&quot;, &quot;codom&quot; =&gt; &quot;V&quot;, &quot;dom&quot; =&gt; &quot;E&quot;)], &quot;AttrType&quot; =&gt; [Dict(&quot;name&quot; =&gt; &quot;Label&quot;)], &quot;Attr&quot; =&gt; [Dict(&quot;name&quot; =&gt; &quot;vlabel&quot;, &quot;codom&quot; =&gt; &quot;Label&quot;, &quot;dom&quot; =&gt; &quot;V&quot;), Dict(&quot;name&quot; =&gt; &quot;elabel&quot;, &quot;codom&quot; =&gt; &quot;Label&quot;, &quot;dom&quot; =&gt; &quot;E&quot;)], &quot;equations&quot; =&gt; Any[])2</code></pre><p>An example labeled graph using symbols for the vertex and edge names. Note that you can use unicode symbols in Julia.</p><pre><code class="language-julia hljs">@acset_type VELabeledGraph(SchVELabeledGraph, index=[:src,:tgt])

lg = VELabeledGraph{Symbol}()
add_parts!(lg, :V, 4, vlabel=[:a, :b, :c, :d])
add_parts!(lg, :E, 2, src=[1,2], tgt=[2,3], elabel=[:e₁, :e₂])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1:2</code></pre><p>This Graph is represented by the following JSON. Now you can see that the vertices have their <code>vlabels</code></p><pre><code class="language-julia hljs">JSON3.print(generate_json_acset(lg), 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{Symbol, Any}(:V =&gt; @NamedTuple{_id::Int64, vlabel::Symbol}[(_id = 1, vlabel = :a), (_id = 2, vlabel = :b), (_id = 3, vlabel = :c), (_id = 4, vlabel = :d)], :E =&gt; @NamedTuple{_id::Int64, src::Int64, tgt::Int64, elabel::Symbol}[(_id = 1, src = 1, tgt = 2, elabel = :e₁), (_id = 2, src = 2, tgt = 3, elabel = :e₂)], :Label =&gt; @NamedTuple{_id::Int64}[])2</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« ACSets.jl</a><a class="docs-footer-nextpage" href="../ADTs/">Specifying acsets using Algebraic Data Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Saturday 19 April 2025 19:33">Saturday 19 April 2025</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
