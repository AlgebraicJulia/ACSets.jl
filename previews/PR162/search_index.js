var documenterSearchIndex = {"docs":
[{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"EditURL = \"../../literate/json_serialization.jl\"","category":"page"},{"location":"generated/json_serialization/#Serializing-acsets-as-JSON","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"","category":"section"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"Catlab supports the serialization of attributed C-sets (acsets) into JSON with their schemas. This functionality should allow you to interoperate with database representations in other languages by serializing both the data and the type into a network interoperability layer.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"import JSON3, JSONSchema\n\nusing ACSets","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"You can interact with the schema representation using JSON Schema with the write_json_acset_schema and read_json_acset_schema functions.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"function roundtrip_json_acset_schema(schema)\n  mktempdir() do dir\n    path = joinpath(dir, \"schema.json\")\n    write_json_acset_schema(schema, path)\n    read_json_acset_schema(path)\n  end\nend","category":"page"},{"location":"generated/json_serialization/#The-JSONSchema-for-Schemas","page":"Serializing acsets as JSON","title":"The JSONSchema for Schemas","text":"","category":"section"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"The following code shows how to view the schema for storing schemas. You can see that this data is encoded in the standardized JSONSchema format, which is a generic way of representing data structures that are serialized to JSON. Notice that there are properties for Homs and Obs. The Homs have fields like name, dom, and codom. The Obs just have a name. AttrTypes are like Obs, but they store the name of the type that the attribute can have. In Julia, the Schemas are parametric in the AttrTypes so that uses can set those types at instance creation time. Attrs are the names of columns that point into the AttrTypes.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"json_schema = JSONSchema.Schema(acset_schema_json_schema())\nJSON3.print(json_schema, 2)","category":"page"},{"location":"generated/json_serialization/#Example-1:-Discrete-Dynamical-Systems","page":"Serializing acsets as JSON","title":"Example 1: Discrete Dynamical Systems","text":"","category":"section"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"Here is an example of an ACSet schema for Discrete Dynamical Systems. A DDS is just a set X whose elements we call states, and a function next, which take the current state and gives you the next state. Such systems are used to model processes that occur autonomously and are the simplest possible dynamical system.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"SchDDS = BasicSchema([:X], [(:next,:X,:X)])\n\nJSON3.print(generate_json_acset_schema(SchDDS), 2)","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"LabeledDDS are a variation on DDS where the states can have symbolic names. In Catlab, every element of an object has to be identified by its integer row number. This comes out of a tradition in database design where every table has a natural number primary key. In mathematics, we often want to think of the state space not as a set of integers, but as an arbitrary set. In Catlab, we call that set the Labels and use a label attribute to implement the mapping of state numbers to state labels. This way the underlying database implementation can still be designed aroung natural number primary keys, but the user can use symbolic labels. Note also that this shows the schema inheritance. We state that a SchLabeledDDS inherits from SchDDS by adding a label attribute of type Label.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"SchLabeledDDS = BasicSchema([:X], [(:next,:X,:X)],\n                            [:Label], [(:label,:X,:Label)])\n\nJSON3.print(generate_json_acset_schema(SchLabeledDDS), 2)","category":"page"},{"location":"generated/json_serialization/#Example-2:-Labeled-DDS","page":"Serializing acsets as JSON","title":"Example 2: Labeled DDS","text":"","category":"section"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"With the LabeledDDS, we will create an instance by specifying data that fits the schema. Then we will create the JSON output to show how it is encoded. The JSON encoded schema above tells you how to read the JSON encoded data below. You can see that the LabeledDDS will have a set for X with a Hom for next and an attribute for label. Thus we can expect to see the JSON encoding of a single table database below:     1. The first level of JSON is keyed by the table names     2. Each Table is an array of rows     3. Each row is an object keyed by fields. This is the simplest way to put a relational database in a JSON document. It is a little redundant, because the field names are repeated for each row. But that makes it easy to emit and easy to parse. If this becomes a problem, we can upgrade to a more efficient representation by writing more sophisticated parsers. Something like https://github.com/JuliaIO/MsgPack.jl would be appropriate.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"@acset_type LabeledDDS(SchLabeledDDS, index=[:next, :label])\n\nldds = LabeledDDS{Int}()\nadd_parts!(ldds, :X, 4, next=[2,3,4,1], label=[100, 101, 102, 103])\nJSON3.print(generate_json_acset(ldds),2)","category":"page"},{"location":"generated/json_serialization/#Example-3:-Graphs","page":"Serializing acsets as JSON","title":"Example 3: Graphs","text":"","category":"section"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"Relational databases are great, because they are capable of representing almost anything that can be stored on a computer. We move up to graphs, which is a nice data structure you have probably seen before. Notably, graphs have two tables, one for edges and one for vertices. These are the category theorist's graph, which means that they support multiple parallel edges and self-loops.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"# Syntax available in Catlab:\n# @present SchGraph(FreeSchema) begin\n#   V::Ob\n#   E::Ob\n#   src::Hom(E,V)\n#   tgt::Hom(E,V)\n# end\n\nSchGraph = BasicSchema([:V,:E], [(:src,:E,:V),(:tgt,:E,:V)])\n\nJSON3.print(generate_json_acset_schema(SchGraph), 2)","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"An example graph with 4 vertices and 2 edges.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"@acset_type Graph(SchGraph, index=[:src, :tgt])\n\ng = Graph()\nadd_parts!(g, :V, 4)\nadd_parts!(g, :E, 2, src=[1,2], tgt=[2,3])","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"Note that the vertices are listed out in a somewhat silly way. They are given as a table with no columns, so they show up in the JSON as a bunch of empty objects. This is for consistency with our next example.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"JSON3.print(generate_json_acset(g), 2)","category":"page"},{"location":"generated/json_serialization/#Example-4:-Vertex-and-Edge-Labeled-Graph-Graph-Schema","page":"Serializing acsets as JSON","title":"Example 4: Vertex and Edge Labeled Graph Graph Schema","text":"","category":"section"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"You can extend schemas by adding more tables and columns. This inheritance is flattened when you serialize to JSON, but could be encoded in a future version.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"# Syntax available in Catlab:\n# @present SchVELabeledGraph <: SchGraph begin\n#    Label::AttrType\n#    vlabel::Attr(V,Label)\n#    elabel::Attr(E,Label)\n# end\n\nSchVELabeledGraph = BasicSchema([:V,:E], [(:src,:E,:V),(:tgt,:E,:V)],\n  [:Label], [(:vlabel,:V,:Label),(:elabel,:E,:Label)])\n\nJSON3.print(generate_json_acset_schema(SchVELabeledGraph), 2)","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"An example labeled graph using symbols for the vertex and edge names. Note that you can use unicode symbols in Julia.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"@acset_type VELabeledGraph(SchVELabeledGraph, index=[:src,:tgt])\n\nlg = VELabeledGraph{Symbol}()\nadd_parts!(lg, :V, 4, vlabel=[:a, :b, :c, :d])\nadd_parts!(lg, :E, 2, src=[1,2], tgt=[2,3], elabel=[:e₁, :e₂])","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"This Graph is represented by the following JSON. Now you can see that the vertices have their vlabels","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"JSON3.print(generate_json_acset(lg), 2)","category":"page"},{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [\n  ACSetInterface,\n  ACSetSerialization,\n  ACSets,\n  ACSets.ColumnImplementations,\n  ACSets.Columns,\n  ACSets.Defaults,\n  DenseACSets,\n  ExcelACSets,\n  ACSets.IndexUtils,\n  InterTypes,\n  JSONACSets,\n  ACSets.Mappings,\n  NautyInterface,\n  ACSets.PreimageCaches,\n  Schemas]","category":"page"},{"location":"api/#ACSets.ACSetInterface.ACSet","page":"Library Reference","title":"ACSets.ACSetInterface.ACSet","text":"Abstract base type for acsets, static or dynamic.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ACSetInterface.DenseParts","page":"Library Reference","title":"ACSets.ACSetInterface.DenseParts","text":"Part IDs are densely packed without gaps.\n\nMutations are eager and garbage collection is a no-op. Deletion or identification of parts may invalidate external references to particular parts.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ACSetInterface.MarkAsDeleted","page":"Library Reference","title":"ACSets.ACSetInterface.MarkAsDeleted","text":"Mark parts as deleted when they are removed.\n\nDeletions are lazy and arrays are not resized until garbage collection. Parts can be deleted without invalidating external references to other parts.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ACSetInterface.MarkAsDeletedUnionFind","page":"Library Reference","title":"ACSets.ACSetInterface.MarkAsDeletedUnionFind","text":"Combination of MarkAsDeleted and UnionFind.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ACSetInterface.PartsType","page":"Library Reference","title":"ACSets.ACSetInterface.PartsType","text":"Type of part IDs to use in an acset.\n\nThe choice of parts type does not alter the mathematical model but it does affect the performance tradeoffs of the acset data structure, the assumptions that can be made about the part IDs, and whether garbage collection (gc!) is relevant.\n\nType parameter S is the collection type (Int, BitSet, etc) and type parameter T is the element type (Int, Symbol, etc), mirroring the two type parameters of FinSet in Catlab.\n\nThe default choice of parts type is DenseParts.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ACSetInterface.UnionFind","page":"Library Reference","title":"ACSets.ACSetInterface.UnionFind","text":"Allow distinct part IDs to refer to the same logical part.\n\nImplemented using union-find. Garbage collection is an operation that makes sense to perform. Parts can be identified with each other without invalidating external references to particular parts.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ACSetInterface.acset_name","page":"Library Reference","title":"ACSets.ACSetInterface.acset_name","text":"Get the name of an acset at runtime\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.acset_schema","page":"Library Reference","title":"ACSets.ACSetInterface.acset_schema","text":"Get the schema of an acset at runtime.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.add_part!-Tuple{ACSet, Symbol, Any}","page":"Library Reference","title":"ACSets.ACSetInterface.add_part!","text":"Add part of given type to acset, optionally setting its subparts.\n\nReturns the ID of the added part.\n\nSee also: add_parts!.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetInterface.add_parts!","page":"Library Reference","title":"ACSets.ACSetInterface.add_parts!","text":"Add parts of given type to acset, optionally setting their subparts.\n\nReturns the range of IDs for the added parts.\n\nSee also: add_part!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.cascading_rem_part!-Tuple{ACSet, Any, Any}","page":"Library Reference","title":"ACSets.ACSetInterface.cascading_rem_part!","text":"Remove part and all parts incident to it, recursively.\n\nCf. rem_part!, which is not recursive.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetInterface.cascading_rem_parts!","page":"Library Reference","title":"ACSets.ACSetInterface.cascading_rem_parts!","text":"Remove parts and all parts incident to them, recursively.\n\nThe parts may be supplied in any order and may include duplicates.\n\nCf. rem_parts!, which is not recursive.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.codom_parts","page":"Library Reference","title":"ACSets.ACSetInterface.codom_parts","text":"Get the parts of the codomain of a morphism in an acset\n\ndom_parts(acs, f) == parts(acs, Y)\n\nwhere Y is the codom of the f in the schema\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.constructor","page":"Library Reference","title":"ACSets.ACSetInterface.constructor","text":"Get a nullary callable which constructs an (empty) ACSet of the same type\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.copy_parts!","page":"Library Reference","title":"ACSets.ACSetInterface.copy_parts!","text":"Copy parts from a C-set to a C′-set.\n\nThe selected parts must belong to both schemas. All subparts common to the selected parts, including data attributes, are preserved. Thus, if the selected parts form a sub-C-set, then the whole sub-C-set is preserved. On the other hand, if the selected parts do not form a sub-C-set, then some copied parts will have undefined subparts.\n\nTODO: handle colons\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.copy_parts_only!","page":"Library Reference","title":"ACSets.ACSetInterface.copy_parts_only!","text":"Copy parts from a C-set to a C′-set, ignoring all non-data subparts.\n\nThe selected parts must belong to both schemas. Attributes common to both schemas are also copied, but no other subparts are copied.\n\nSee also: copy_parts!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.dom_parts","page":"Library Reference","title":"ACSets.ACSetInterface.dom_parts","text":"Get the parts of the domain of a morphism in an acset\n\ndom_parts(acs, f) == parts(acs, X)\n\nwhere X is the dom of the f in the schema\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.gc!","page":"Library Reference","title":"ACSets.ACSetInterface.gc!","text":"Garbage collect in an acset.\n\nFor some choices of PartsType, this function is a no-op.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.has_part","page":"Library Reference","title":"ACSets.ACSetInterface.has_part","text":"Whether an acset has a part with the given name.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.incident","page":"Library Reference","title":"ACSets.ACSetInterface.incident","text":"Get superparts incident to part in acset.\n\nIf the subpart is indexed, this takes constant time; otherwise, it takes linear time. As with subpart, both single and vectorized access, as well as chained access, are supported. Note that sequences of morphisms are supplied in the usual left-to-right order, so that\n\nincident(g, x, [:src, :vattr])\n\nreturns the list of all edges whose source vertex has vertex attribute x.\n\nIf the chaining of subparts is given as a tuple (e.g.; (:src, :vattr)), then code generation is used to check that the subparts and their order is a valid composition and to improve performance.\n\nNote that when the subpart is indexed, this function returns a view of the underlying index, which should not be mutated. To ensure that a fresh copy is returned, regardless of whether indexing is enabled, set the keyword argument copy=true.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.maxpart","page":"Library Reference","title":"ACSets.ACSetInterface.maxpart","text":"Maximum possible part value of given type in an acset.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.nparts","page":"Library Reference","title":"ACSets.ACSetInterface.nparts","text":"Number of parts of given type in an acset.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.parts-Tuple{Any, Any}","page":"Library Reference","title":"ACSets.ACSetInterface.parts","text":"Parts of given type in an acset.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetInterface.parts_type-Union{Tuple{ACSet{PT}}, Tuple{PT}} where PT","page":"Library Reference","title":"ACSets.ACSetInterface.parts_type","text":"Get the type used to store parts IDs.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetInterface.pretty_tables-Tuple{IO, ACSet}","page":"Library Reference","title":"ACSets.ACSetInterface.pretty_tables","text":"Display an acset using PrettyTables.jl.\n\nThis works for any acset that implements tables.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetInterface.rem_free_vars!-Tuple{ACSet}","page":"Library Reference","title":"ACSets.ACSetInterface.rem_free_vars!","text":"Remove all AttrType parts that are not in the image of any of the attributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetInterface.rem_part!","page":"Library Reference","title":"ACSets.ACSetInterface.rem_part!","text":"Remove part from a C-set.\n\nThe part is removed using the \"pop and swap\" strategy familiar from Graphs.jl, where the \"removed\" part is actually replaced by the last part, which is then deleted. This strategy has important performance benefits since only the last part must be assigned a new ID, as opposed to assigning new IDs to every part following the removed part.\n\nThe removal operation is not recursive. When a part is deleted, any superparts incident to it are retained, but their subparts become undefined (equal to the integer zero). For example, in a graph, if you call rem_part! on a vertex, the edges incident the src and/or tgt vertices of the edge become undefined but the edge itself is not deleted.\n\nIndexing has both positive and negative impacts on performance. On the one hand, indexing reduces the cost of finding affected superparts from linear time to constant time. On the other hand, the indices of subparts must be updated when the part is removed. For example, in a graph, indexing src and tgt makes removing vertices faster but removing edges (slightly) slower.\n\nSee also: rem_parts!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.rem_parts!-Tuple{ACSet, Any, Any}","page":"Library Reference","title":"ACSets.ACSetInterface.rem_parts!","text":"Remove parts from a C-set.\n\nThe parts must be supplied in sorted order, without duplicates.\n\nSee also: rem_part!.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetInterface.set_subpart!","page":"Library Reference","title":"ACSets.ACSetInterface.set_subpart!","text":"Mutate subpart of a part in a C-set.\n\nBoth single and vectorized assignment are supported.\n\nSee also: set_subparts!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.set_subparts!-Union{Tuple{keys}, Tuple{ACSet, Any, NamedTuple{keys}}} where keys","page":"Library Reference","title":"ACSets.ACSetInterface.set_subparts!","text":"Mutate subparts of a part in a C-set.\n\nBoth single and vectorized assignment are supported.\n\nSee also: set_subpart!.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetInterface.subpart","page":"Library Reference","title":"ACSets.ACSetInterface.subpart","text":"Get subpart of part in acset.\n\nBoth single and vectorized access are supported, with a view of the underlying data being returned in the latter case. Chaining, or composition, of subparts is also supported. For example, given a vertex-attributed graph g,\n\nsubpart(g, e, [:src, :vattr])\n\nreturns the vertex attribute of the source vertex of the edge e. As a shorthand, subparts can also be accessed by indexing:\n\ng[e, :src] == subpart(g, e, :src)\n\nIf the chaining of subparts is given as a tuple (e.g.; (:src, :vattr)), then code generation is used to check that the subparts and their order is a valid composition and to improve performance.\n\nBe warned that indexing with lists of subparts works just like subpart: g[e,[:src,:vattr]] is equivalent to subpart(g, e, [:src,:vattr]). This convention differs from DataFrames but note that the alternative interpretation of [:src,:vattr] as two independent columns does not even make sense, since they have different domains (belong to different tables).\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.subpart_type","page":"Library Reference","title":"ACSets.ACSetInterface.subpart_type","text":"Get the type assigned to a subpart in an acset, i.e.\n\nsubpart_type(acs::WeightedGraph{T}, :weight) == T\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.tables","page":"Library Reference","title":"ACSets.ACSetInterface.tables","text":"Get a named tuple of Tables.jl-compatible tables from an acset\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetInterface.undefined_subparts","page":"Library Reference","title":"ACSets.ACSetInterface.undefined_subparts","text":"Given a hom, find which parts in its domain are undefined.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.fill!-Tuple{ACSet, Symbol, Integer}","page":"Library Reference","title":"Base.fill!","text":"Fill an ACSet\n\nConsider a cycle graph g with 3 vertices and 3 edges. Then\n\nfill!(g, :V, 5) # = 4:5\n\nadds vertices 4 and 5. Suppose instead we added an edge,\n\nfill!(g, :E, 4) # = 4:4\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetInterface.@acset-Tuple{Any, Any}","page":"Library Reference","title":"ACSets.ACSetInterface.@acset","text":"This provides a shorthand for constructing an acset by giving its parts and subparts\n\nUsage:\n\n@acset WeightedGraph{String} begin   V = 2   E = 1   src = [1]   tgt = [2]   weight = [\"fig\"] end\n\n\n\n\n\n","category":"macro"},{"location":"api/#ACSets.ACSetSerialization","page":"Library Reference","title":"ACSets.ACSetSerialization","text":"Serializing and deserializing acsets to/from different formats.\n\n\n\n\n\n","category":"module"},{"location":"api/#ACSets.ACSetSerialization.read_acset!","page":"Library Reference","title":"ACSets.ACSetSerialization.read_acset!","text":"Mutating variant of read_acset.\n\nArguments\n\nacset: acset to write to\nsource: source to read from\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.ACSetSerialization.read_acset-Tuple{Any, Any}","page":"Library Reference","title":"ACSets.ACSetSerialization.read_acset","text":"Read/deserialize an acset from an external source.\n\nSupported source types include:\n\nAbstractDict: assumed to be JSON data\nXLSX.XLSXFile: Microsoft Excel file (requires XLSX.jl)\n\nArguments\n\ncons: constructor for acset, e.g., the type of a struct acset\nsource: source to read from\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ColumnImplementations.AttrVar","page":"Library Reference","title":"ACSets.ColumnImplementations.AttrVar","text":"Maps from attribute variables can go into arbitrary Julia types or other  variables (indexed by integers). This wrapper types allows us to not confuse  our Attr Variable indices with the Julia type of Int\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ColumnImplementations.DenseColumn","page":"Library Reference","title":"ACSets.ColumnImplementations.DenseColumn","text":"A column for a vec-backed unindexed attr\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ColumnImplementations.DenseFinColumn","page":"Library Reference","title":"ACSets.ColumnImplementations.DenseFinColumn","text":"A column for a vec-backed unindexed hom\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ColumnImplementations.DenseIndexedColumn","page":"Library Reference","title":"ACSets.ColumnImplementations.DenseIndexedColumn","text":"A column for a vec-backed indexed attr\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ColumnImplementations.DenseIndexedFinColumn","page":"Library Reference","title":"ACSets.ColumnImplementations.DenseIndexedFinColumn","text":"A column for a vec-backed indexed hom\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ColumnImplementations.DenseInjectiveColumn","page":"Library Reference","title":"ACSets.ColumnImplementations.DenseInjectiveColumn","text":"A column for a vec-backed unindexed attr\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ColumnImplementations.DenseInjectiveFinColumn","page":"Library Reference","title":"ACSets.ColumnImplementations.DenseInjectiveFinColumn","text":"A column for a vec-backed injective hom\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ColumnImplementations.SparseColumn","page":"Library Reference","title":"ACSets.ColumnImplementations.SparseColumn","text":"A column for a dict-backed unindexed hom with key type K\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ColumnImplementations.SparseFinColumn","page":"Library Reference","title":"ACSets.ColumnImplementations.SparseFinColumn","text":"A column for a dict-backed unindexed hom with key type K\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ColumnImplementations.SparseIndexedColumn","page":"Library Reference","title":"ACSets.ColumnImplementations.SparseIndexedColumn","text":"A column for a dict-backed indexed hom with key type K\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ColumnImplementations.SparseIndexedFinColumn","page":"Library Reference","title":"ACSets.ColumnImplementations.SparseIndexedFinColumn","text":"A column for a dict-backed indexed hom with key type K\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ColumnImplementations.SparseInjectiveColumn","page":"Library Reference","title":"ACSets.ColumnImplementations.SparseInjectiveColumn","text":"A column for a dict-backed injective hom with key type K\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ColumnImplementations.SparseInjectiveFinColumn","page":"Library Reference","title":"ACSets.ColumnImplementations.SparseInjectiveFinColumn","text":"A column for a dict-backed injective hom with key type K\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ColumnImplementations.indexchoice-Tuple{Any, Any, Any}","page":"Library Reference","title":"ACSets.ColumnImplementations.indexchoice","text":"Convert specification of indexing via lists of indexed and unique_indexed morphisms into a specific enum choice.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.Columns.Column","page":"Library Reference","title":"ACSets.Columns.Column","text":"A column wraps a mapping and a cache of its preimages, and provides methods that do coordinated updates of both.\n\nAbstract Fields:\n\nm::Mapping{S,T}\npc::PreimageCache{S,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.Defaults.Default","page":"Library Reference","title":"ACSets.Defaults.Default","text":"This is a hack in order to pass in a default initializer for DefaultVecMap as a type parameter\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.DenseACSets","page":"Library Reference","title":"ACSets.DenseACSets","text":"These are ACSets where the set associated to each object is of the form 1:n\n\n\n\n\n\n","category":"module"},{"location":"api/#ACSets.DenseACSets.AnonACSet","page":"Library Reference","title":"ACSets.DenseACSets.AnonACSet","text":"This works the same as something made with @acset_type, only the types of the parts and subparts are stored as type parameters. Thus, this can be used with any schema.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.DenseACSets.BitSetParts","page":"Library Reference","title":"ACSets.DenseACSets.BitSetParts","text":"Parts IDs are a subset of contiguous integers from 1 to n.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.DenseACSets.DynamicACSet","page":"Library Reference","title":"ACSets.DenseACSets.DynamicACSet","text":"This is a SimpleACSet which has the schema as a field value rather than as a type parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.DenseACSets.DynamicACSet-Union{Tuple{StructACSet{S, Ts, PT}}, Tuple{PT}, Tuple{Ts}, Tuple{S}} where {S, Ts, PT}","page":"Library Reference","title":"ACSets.DenseACSets.DynamicACSet","text":"Cast StructACSet into a DynamicACSet\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.DenseACSets.IntParts","page":"Library Reference","title":"ACSets.DenseACSets.IntParts","text":"Part IDs are contiguous integers from 1 to n.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.DenseACSets.SimpleACSet","page":"Library Reference","title":"ACSets.DenseACSets.SimpleACSet","text":"A SimpleACSet is an abstract type for any acset that has a certain layout\n\nSpecifically, subtypes of SimpleACSet are expected to have a parts field which is a mapping from symbols to ints, and a subparts field which is a mapping from symbols to columns, which are any data structure that satisfies the interface given in Columns.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.DenseACSets.StructACSet","page":"Library Reference","title":"ACSets.DenseACSets.StructACSet","text":"A StructACSet is a SimpleACSet where the schema and the types assigned to the attrtypes are available in the type.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.DenseACSets.StructACSet-Union{Tuple{DynamicACSet{PT}}, Tuple{PT}} where PT","page":"Library Reference","title":"ACSets.DenseACSets.StructACSet","text":"Cast DynamicACSet into a StructACSet\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.DenseACSets.StructCSet","page":"Library Reference","title":"ACSets.DenseACSets.StructCSet","text":"A special case where there are no attributes.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.ACSetInterface.gc!-Tuple{ACSet{<:MarkAsDeleted}}","page":"Library Reference","title":"ACSets.ACSetInterface.gc!","text":"Reindex the parts of the acset such that there are no gaps between the indices. Return a vector for each part mapping the new parts into the old parts. \n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetInterface.incident-Tuple{SimpleACSet, AbstractVector, Symbol}","page":"Library Reference","title":"ACSets.ACSetInterface.incident","text":"Calling incident on a range of values, e.g. incident(G, 1:2, :src) is  equivalent to concatenating the results of incident on each part, i.e.  [incident(G,1,:src), incident(G,2,:src)].\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.DenseACSets.ACSetTableType-Tuple{Type, Symbol}","page":"Library Reference","title":"ACSets.DenseACSets.ACSetTableType","text":"This takes an ACSet type, and produces an AnonACSet which represents an acset with just the object passed in, and then all of the attributes of that object.\n\nTODO: rename this to be less confusing with ACSetTable. Maybe ASet (attributed set)\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.DenseACSets.AnonACSetType-Tuple{Schema}","page":"Library Reference","title":"ACSets.DenseACSets.AnonACSetType","text":"This can be used to fill out the type parameters to an AnonACSet ahead of time.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.DenseACSets.delete_subobj!-Tuple{ACSet, Any}","page":"Library Reference","title":"ACSets.DenseACSets.delete_subobj!","text":"Return a mapping of from parts of updated X to the old X\n\nNote: the correctness is dependent on the implementation details of rem_parts!\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.DenseACSets.delete_subobj-Tuple{ACSet, Any}","page":"Library Reference","title":"ACSets.DenseACSets.delete_subobj","text":"Identify which parts of an ACSet need to be deleted if some initial collection  of parts is to be deleted. E.g. deleting a vertex deletes its edge\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.DenseACSets.genericize-Tuple{Type, Vector{TypeVar}}","page":"Library Reference","title":"ACSets.DenseACSets.genericize","text":"The type variables that we have generated might not match up with the type variables that are created as generic parameters to the struct acset, this is a way of making the two line up\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.DenseACSets.idx-Tuple{ACSets.DenseACSets.ACSetRow}","page":"Library Reference","title":"ACSets.DenseACSets.idx","text":"Get index of row in parent acset.\n\nGiven an ACSetRow object from the Tables.jl interface, return the ID of the correspond part in the parent acset the row was derived from.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.DenseACSets.pi_type-Tuple{Vector{Tuple{Symbol, Type}}}","page":"Library Reference","title":"ACSets.DenseACSets.pi_type","text":"Creates a named tuple type\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.DenseACSets.pi_type_elt-Tuple{Vector{Tuple{Symbol, Expr}}}","page":"Library Reference","title":"ACSets.DenseACSets.pi_type_elt","text":"Creates a quoted element of a named tuple\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.DenseACSets.struct_acset-Tuple{Symbol, Any, Schema{Symbol}}","page":"Library Reference","title":"ACSets.DenseACSets.struct_acset","text":"Create the struct declaration for a StructACSet from a Presentation\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.parent-Tuple{ACSets.DenseACSets.ACSetTable}","page":"Library Reference","title":"Base.parent","text":"Get parent acset.\n\nGiven a ACSetTable or ACSetRow object from the Tables.jl interface, return the parent acset the object was derived from.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.DenseACSets.@abstract_acset_type-Tuple{Any}","page":"Library Reference","title":"ACSets.DenseACSets.@abstract_acset_type","text":"We want control over the type class hierarchy of acsets; this allows us to create abstract types that subtype StructACSet. For instance, we might have an AbstractGraph type, and then assume (this is not enforced) that any subtype of AbstractGraph has E,V,src,tgt in its schema.\n\n\n\n\n\n","category":"macro"},{"location":"api/#ACSets.DenseACSets.@acset_type-Tuple{Any}","page":"Library Reference","title":"ACSets.DenseACSets.@acset_type","text":"This macro creates custom structs that subclass StructACSet{S} for specific S. These are used for acsets whose schema is known at compile time.\n\n\n\n\n\n","category":"macro"},{"location":"api/#ACSets.ACSetSerialization.ExcelACSets","page":"Library Reference","title":"ACSets.ACSetSerialization.ExcelACSets","text":"Read acsets from Microsoft Excel files.\n\n\n\n\n\n","category":"module"},{"location":"api/#ACSets.ACSetSerialization.ExcelACSets.read_xlsx_acset-Tuple{Any, Union{AbstractString, IO}}","page":"Library Reference","title":"ACSets.ACSetSerialization.ExcelACSets.read_xlsx_acset","text":"Read acset from an Excel (.xlsx) file.\n\nThis is a convenience function that loads the Excel file and then calls read_acset. To use this function, the package XLSX.jl must be installed and imported.\n\nArguments\n\ncons: constructor for acset, e.g., the acset type for struct acsets\nsource: filename or IO stream from which to read Excel file\ntables=(;): dictionary or named tuple mapping object names in acset schema to Excel table specifications\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.IndexUtils.deletesorted!-Tuple{AbstractVector, Any}","page":"Library Reference","title":"ACSets.IndexUtils.deletesorted!","text":"Delete one occurrence of value from sorted vector, if present.\n\nReturns whether an occurence was found and deleted.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.IndexUtils.insertsorted!-Tuple{AbstractVector, Any}","page":"Library Reference","title":"ACSets.IndexUtils.insertsorted!","text":"Insert into sorted vector, preserving the sorting.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.InterTypes.ACSetTypeSpec","page":"Library Reference","title":"ACSets.InterTypes.ACSetTypeSpec","text":"A specification for the type of an acset.\n\nFields\n\ngenericname::Union{Symbol, Nothing}: The name for the generic version of the acset, with type parameters.\nNote that the name assigned to this in the declaration is the name with type parameters pre-specified.\nIf there are no attribute types, then this is nothing.\nabstract_type::Union{Symbol, Nothing}: The parent abstract type for the acset.\nschemaname::Symbol\nschema::TypedSchema{Symbol, InterType}\nindex::Vector{Symbol}\nunique_index::Vector{Symbol}\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.AbstractACSetType","page":"Library Reference","title":"ACSets.InterTypes.AbstractACSetType","text":"An abstract acset type which ACSets can subtype. Mostly used for backwards compatibility with AlgebraicJulia code.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.Alias","page":"Library Reference","title":"ACSets.InterTypes.Alias","text":"An alias for an existing type\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.Field","page":"Library Reference","title":"ACSets.InterTypes.Field","text":"A field of a struct. Used in Variant and Record.\n\nThe T parameter will always be InterType, but this is mutually-recursive with InterType so we have to be generic here.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.InterType","page":"Library Reference","title":"ACSets.InterTypes.InterType","text":"An intertype expression representing a type.\n\nTODO: Generic types TODO: Remove anonymous sums, anonymous products TODO: Separate out primitives, so that this is something like\n\n@data InterType begin\n  PrimType(prim::InterTypePrimitive)\n  TypeRef(path::RefPath)\n  TypeApp(type::InterType, args::Vector{InterType})\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.InterTypeDecl","page":"Library Reference","title":"ACSets.InterTypes.InterTypeDecl","text":"An intertype declaration.\n\nDoes not include the name of the declaration.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.InterTypeModule","page":"Library Reference","title":"ACSets.InterTypes.InterTypeModule","text":"A collection of intertype declarations packaged together. May refer to other InterTypeModules via the imports field.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.JSONTarget","page":"Library Reference","title":"ACSets.InterTypes.JSONTarget","text":"JSONTarget\n\nSpecifies a serialization target of JSON Schema when generating a module.\n\nTODO: This should really be called something like JSONSchemaTarget.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.JacksonTarget","page":"Library Reference","title":"ACSets.InterTypes.JacksonTarget","text":"JacksonTarget\n\nTargets the creation of a directory full of .java files that use the Jackson JSON library.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.NamedACSetType","page":"Library Reference","title":"ACSets.InterTypes.NamedACSetType","text":"An acset type, with customizations like choice of indices, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.PydanticTarget","page":"Library Reference","title":"ACSets.InterTypes.PydanticTarget","text":"PydanticTarget\n\nTargets the creation of .py files that use the Pydantic library which enables integration with the Python language (specifically when (de)serializing JSON).\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.RefPath","page":"Library Reference","title":"ACSets.InterTypes.RefPath","text":"A non-empty linked list of symbols representing something like foo.bar.baz.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.RefThere","page":"Library Reference","title":"ACSets.InterTypes.RefThere","text":"E.g. mod.name\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.SExp","page":"Library Reference","title":"ACSets.InterTypes.SExp","text":"A very simple s-expression data structure.\n\nWe use this to write the intertype schema to a string and then hash it to get a version identifier.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.SchemaDecl","page":"Library Reference","title":"ACSets.InterTypes.SchemaDecl","text":"A schema for acsets. Does not declare the acset type yet, however, that is done by NamedACSetType.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.Struct","page":"Library Reference","title":"ACSets.InterTypes.Struct","text":"A struct type, also known as a product type or record type.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.SumType","page":"Library Reference","title":"ACSets.InterTypes.SumType","text":"A sum type, also known as a tagged union.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.Variant","page":"Library Reference","title":"ACSets.InterTypes.Variant","text":"One of the summands of a sum type.\n\nLike Field, the T parameter will always be InterType, but this is mutually-recursive with InterType so we have to be generic here.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.VariantOf","page":"Library Reference","title":"ACSets.InterTypes.VariantOf","text":"A variant of a sum type, i.e. one of the summands. These are implicitly produced when declaring a sum type, and the data of the variant (i.e. the fields) are in the parent sum type.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.InterTypes.generate_module","page":"Library Reference","title":"ACSets.InterTypes.generate_module","text":"generate_module(mod::Module, target::Type{<:ExportTarget}, path=\".\"; target_specific_args...)\n\nGenerate files that define the intertypes for the specified target. \n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.InterTypes.tojsonschema-Tuple{InterType}","page":"Library Reference","title":"ACSets.InterTypes.tojsonschema","text":"tojsonschema(type::InterType)\n\nConvert an InterType to a JSONSchema representation.\n\nTODO: We could use multiple dispatch instead of the @match here, which might be cleaner\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.InterTypes.topy-Tuple{InterType}","page":"Library Reference","title":"ACSets.InterTypes.topy","text":"topy(intertype::InterType; forward_ref=true)\n\nConverts an intertype into a python code string.\n\nTODO: See comment for toexpr\n\nTODO: Should we use something like a stringbuilder instead of manually concatenating strings? I.e., a tree of strings with O(1) append/splice, that we write out to a single string at the end?\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.Schemas.toexpr","page":"Library Reference","title":"ACSets.Schemas.toexpr","text":"function toexpr(x) end\n\nUsed to convert intertype data types to Expr.\n\nTODO: Should we unify tojsonschema, toexpr, and topy into a single function with an extra argument to control dispatch?\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.InterTypes.@intertypes-Tuple{Any, Any}","page":"Library Reference","title":"ACSets.InterTypes.@intertypes","text":"@intertypes \"file.it\" module modulename end\n\nUsed to import an intertypes file into Julia.\n\nTODO: maybe we should just build a .jl file from an .it file directly.\n\n\n\n\n\n","category":"macro"},{"location":"api/#ACSets.ACSetSerialization.JSONACSets","page":"Library Reference","title":"ACSets.ACSetSerialization.JSONACSets","text":"JSON serialization of acsets and acset schemas.\n\n\n\n\n\n","category":"module"},{"location":"api/#ACSets.ACSetSerialization.JSONACSets.acset_schema_json_schema-Tuple{}","page":"Library Reference","title":"ACSets.ACSetSerialization.JSONACSets.acset_schema_json_schema","text":"Returns the JSON schema for the JSON serialization of ACSet schemas.\n\nThe result is a JSON-able object (dictionary) from which a JSONSchema.Schema can be constructed, using the package JSONSchema.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetSerialization.JSONACSets.generate_json_acset-Tuple{ACSet}","page":"Library Reference","title":"ACSets.ACSetSerialization.JSONACSets.generate_json_acset","text":"Generate JSON-able object representing an ACSet.\n\nInverse to parse_json_acset.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetSerialization.JSONACSets.generate_json_acset_schema-Tuple{Schema}","page":"Library Reference","title":"ACSets.ACSetSerialization.JSONACSets.generate_json_acset_schema","text":"Generate JSON-able object representing an ACSet schema.\n\nGiven an ACSet schema (either a Schema or a Presentation), such as SchGraph or SchWeightedGraph, construct a JSON-able dictionary with keys \"Ob\", \"Hom\", \"AttrType\", and \"Attr\", conforming to the JSON Schema in acset_schema_json_schema.\n\nInverse to parse_json_acset_schema.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetSerialization.JSONACSets.parse_json_acset-Tuple{Any, AbstractDict}","page":"Library Reference","title":"ACSets.ACSetSerialization.JSONACSets.parse_json_acset","text":"Parse JSON-able object or JSON string representing an ACSet.\n\nInverse to generate_json_acset.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetSerialization.JSONACSets.parse_json_acset_schema-Tuple{Type{BasicSchema}, AbstractDict}","page":"Library Reference","title":"ACSets.ACSetSerialization.JSONACSets.parse_json_acset_schema","text":"Parse JSON-able object or JSON string representing an ACSet schema.\n\nGiven a JSON object specifying a presentation of an ACSet schema, construct a schema object: either a Schema or, by default, a Presentation.\n\nInverse to generate_json_acset_schema.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetSerialization.JSONACSets.read_json_acset-Tuple{Any, AbstractString}","page":"Library Reference","title":"ACSets.ACSetSerialization.JSONACSets.read_json_acset","text":"Deserialize an ACSet object from a JSON file.\n\nInverse to write_json_acset.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetSerialization.JSONACSets.read_json_acset_schema-Tuple{Any, AbstractString}","page":"Library Reference","title":"ACSets.ACSetSerialization.JSONACSets.read_json_acset_schema","text":"Deserialize ACSet schema from JSON file.\n\nSimilar to parse_json_acset_schema except reads from a file. Inverse to write_json_acset_schema.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetSerialization.JSONACSets.write_json_acset-Tuple{ACSet, AbstractString}","page":"Library Reference","title":"ACSets.ACSetSerialization.JSONACSets.write_json_acset","text":"Serialize an ACSet object to a JSON file.\n\nInverse to read_json_acset.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.ACSetSerialization.JSONACSets.write_json_acset_schema-Tuple{Any, AbstractString}","page":"Library Reference","title":"ACSets.ACSetSerialization.JSONACSets.write_json_acset_schema","text":"Serialize ACSet schema to JSON file.\n\nSimilar to generate_json_acset_schema except writes to a file. Inverse to read_json_acset_schema.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSON3.write-Tuple{IO, ACSet}","page":"Library Reference","title":"JSON3.write","text":"Dispatch for ACSet\n\nDispatches write to accept ACSets\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.Mappings.Mapping","page":"Library Reference","title":"ACSets.Mappings.Mapping","text":"A mapping is essentially an AbstractDict, but we support a couple more methods, like map, and so in order to not do type piracy we make our own abstract type to define methods on. Additionally, access to undefined indices will return nothing rather than erroring; this means that a Mapping{K,Nothing} will behave as if everything is undefined. Don't do this.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.NautyInterface","page":"Library Reference","title":"ACSets.NautyInterface","text":"Compute automorphism group via nauty.c\n\n\n\n\n\n","category":"module"},{"location":"api/#ACSets.NautyInterface.CSetNautyRes","page":"Library Reference","title":"ACSets.NautyInterface.CSetNautyRes","text":"NautyResults must satisfy the following interface\n\nstrhsh: string value representing the isomorphism class\norbits: partitions of Cset parts into orbits e.g. if E#2 = E#5, then these two elements are symmetric\ngenerators: generating automorphisms of the automorphism group\nngroup: number of elements in the automorphism group\ncanonmap: isomorphism from the input into the canonoical isomorph\ncanon: canonical isomorph (codom of canonmap)\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.NautyInterface.CSetNautyRes-Tuple{T} where T<:ACSet","page":"Library Reference","title":"ACSets.NautyInterface.CSetNautyRes","text":"CSetNautyRes for an empty ACSet\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.NautyInterface.UnDiGraph","page":"Library Reference","title":"ACSets.NautyInterface.UnDiGraph","text":"Data structure for simple undirected graph.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.NautyInterface.all_autos-Tuple{CSetNautyRes}","page":"Library Reference","title":"ACSets.NautyInterface.all_autos","text":"Take advantage of the very special structure of automorphism generators given by nauty to efficiently enumerate the automorphism group. We iteratively expand our automorphism group with each generator. A while loop  explores the possible words that we can built (starting with gₙ₊₁)\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.NautyInterface.apply-Tuple{ACSet, Dict{Symbol, Permutations.Permutation}}","page":"Library Reference","title":"ACSets.NautyInterface.apply","text":"Action of a permutation on a ACSet, X. Results in a new ACSet, Y, and a map X->Y\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.NautyInterface.attr_dict-Tuple{ACSet}","page":"Library Reference","title":"ACSets.NautyInterface.attr_dict","text":"Get all attribute values that are touched upon by the ACSet. Order them.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.NautyInterface.call_nauty","page":"Library Reference","title":"ACSets.NautyInterface.call_nauty","text":"Compute CSetNautyRes from an ACSet.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.NautyInterface.colornames-Tuple{Any}","page":"Library Reference","title":"ACSets.NautyInterface.colornames","text":"List of distinct node types in the undigraph representation of an ACSet\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.NautyInterface.dreadnaut-Tuple{ACSet}","page":"Library Reference","title":"ACSets.NautyInterface.dreadnaut","text":"Construct input for dreadnaut to compute automorphism group generators, canonical permutation/hash, and orbits.\n\nNote the Julia colorsarray must be changed from being 1-indexed to 0-indexed.\n\nDreadnaut parameters:\n\nn - # of vertices g - provide input graph via command line rather than via a file f - use an initial partition of the vertices in the undirected graph c - find a canonical graph b - write out a canonical graph x - run nauty z - make a canonical hash o - write out the orbits\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.NautyInterface.from_adj-Tuple{ACSet, Dict{Symbol, UnitRange}, AbstractMatrix{Bool}}","page":"Library Reference","title":"ACSets.NautyInterface.from_adj","text":"Convert symmetric adjacency matrix to an ACSet which is isomorphic to X.\n\nThe main work is reverse-engineering triangles of the form\n\n                    ↗ src′ₙ\n                  ↙    ↕\n              eₙ <-> srcₙ <-> vₘ\n\ninto hom values for the resulting ACSet. We call srcₙ a \"hom-object\" and  src′ₙ a \"pseudo-hom-object\". eₙ is the \"src ind\" and vₘ is the \"tgt ind\"\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.NautyInterface.get_colorsarray-Tuple{Any, Dict{Symbol, UnitRange}}","page":"Library Reference","title":"ACSets.NautyInterface.get_colorsarray","text":"Specify for nauty input what the initial partition is\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.NautyInterface.get_oinds-Tuple{Any}","page":"Library Reference","title":"ACSets.NautyInterface.get_oinds","text":"Create partition of flattened indices (all parts altogether) to dict with  indices for each distinct object, e.g.:\n\n{V => 1:8, E => 9:13, src => 14:18, tgt => 19:23,      src... => 24:28, tgt... => 29:33, weight => 34:38}\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.NautyInterface.parse_orb-Tuple{ACSet, Any, String}","page":"Library Reference","title":"ACSets.NautyInterface.parse_orb","text":"Parse / postprocess orbits from the end of dreadnaut input\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.NautyInterface.parse_res-Tuple{String, ACSet}","page":"Library Reference","title":"ACSets.NautyInterface.parse_res","text":"Parse nauty stdout text\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.NautyInterface.prime-Tuple{Symbol}","page":"Library Reference","title":"ACSets.NautyInterface.prime","text":"Avoid a name conflict with a user-defined ob or hom\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.NautyInterface.to_perm-Tuple{Permutations.Permutation, Dict{Symbol, <:UnitRange}}","page":"Library Reference","title":"ACSets.NautyInterface.to_perm","text":"Convert an all-parts permutation into a symbol-indexed set of  permutations, given a partition of 1:n_total into ranges for each symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.NautyInterface.to_udg-Tuple{ACSet}","page":"Library Reference","title":"ACSets.NautyInterface.to_udg","text":"Convert C-Set to an adjacency matrix of an undirected simple graph.\n\nthe matrix has rows for all parts (e.g. |E| and |V|), all homs (e.g. |E| quantity of src & tgt nodes), and another copy of all homs (called, e.g., _src and _tgt). For a given edge in the category of elements eₙ – srcₙ –> vₘ, we set edges in the simple diagraph:\n\n    ↗ _srcₙ\n  ↙    ↕\neₙ <-> srcₙ <-> vₘ\n\nFor attributes, there is no possibility of Attr(X,X), so we simply have, e.g.:     eₘ <-> weightₘ <-> Numberₙ\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.PreimageCaches.InjectiveCache","page":"Library Reference","title":"ACSets.PreimageCaches.InjectiveCache","text":"An preimage mapping for injective maps.\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.PreimageCaches.PreimageCache","page":"Library Reference","title":"ACSets.PreimageCaches.PreimageCache","text":"A PreimageCache is a cache of the preimage of a Mapping. Many of the methods for PreimageCache take in a Mapping; this is so that PreimageCache can choose how much to cache. That is, PreimageCache could be a unit type, and simply dynamically compute the preimage mapping on demand, or it could store the full preimage mapping, or perhaps something in between.\n\nJust like a Mapping, an PreimageCache has a definable codomain, which is a subset of T. Calling add_mapping! and remove_mapping! on elements out of this definable codomain will error.\n\nHowever, a PreimageCache is always defined on all of its definable codomain; it defaults to the empty set.\n\nPreimageCache also has a notion of \"stored\" codomain, where preimages are actually stored.  It is only when the preimage is stored that referential equality of preimage sets will be preserved, and additionally storage can have performance implications.\n\nPreimageCaches should support the following functions:\n\npreimage\nassign!\nunassign!\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.PreimageCaches.StoredPreimageCache","page":"Library Reference","title":"ACSets.PreimageCaches.StoredPreimageCache","text":"An preimage mapping that works by storing the preimages directly. Note: the storage should be a storage that defaults to making empty preimages when expanded or queried out of band, so for instance DefaultVecMap{Preimage, DefaultEmpty{Preimage}}\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.PreimageCaches.TrivialCache","page":"Library Reference","title":"ACSets.PreimageCaches.TrivialCache","text":"The trivial preimage mapping. It just computes preimages on the fly, and the operations for updating it are noops\n\n\n\n\n\n","category":"type"},{"location":"api/#ACSets.PreimageCaches.assign!","page":"Library Reference","title":"ACSets.PreimageCaches.assign!","text":"Arguments:\n\ni::PreimageCache{S,T}\ny::T\nx::S\n\nAdd x to the preimage of y.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.PreimageCaches.preimage","page":"Library Reference","title":"ACSets.PreimageCaches.preimage","text":"Arguments:\n\ndom::Iterable{S}\nm::Mapping{S,T}\ni::PreimageCache{S,T}\ny::T\n\nReturns an iterable of the values in the domain that map onto y.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.PreimageCaches.preimage_multi-Tuple{Any, ACSets.Mappings.Mapping, ACSets.PreimageCaches.PreimageCache, Any}","page":"Library Reference","title":"ACSets.PreimageCaches.preimage_multi","text":"Arguments:\n\ndom::Iterable{S}\nm::Mapping{S,T}\ni::PreimageCache{S,T}\nys::Iterable{T}\n\nSemantically, this is the same as mapping preimage over ys, but the implementation might choose to use a view of an internal data structure of the index instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACSets.PreimageCaches.unassign!","page":"Library Reference","title":"ACSets.PreimageCaches.unassign!","text":"Arguments:\n\ni::PreimageCache{S,T}\ny::T\nx::S\n\nRemove x from the preimage of y.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.Schemas.arrows","page":"Library Reference","title":"ACSets.Schemas.arrows","text":"Parameters:\n\ns::Schema{Name}\n\nNamed Parameters:\n\njust_names::Bool=false\nfrom::Any = nothing\nto::Any = nothing\n\nSame deal as homs, but for homs and attributes.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.Schemas.attrs","page":"Library Reference","title":"ACSets.Schemas.attrs","text":"Parameters:\n\ns::Schema{Name}\n\nNamed Parameters:\n\njust_names::Bool=false\nfrom::Any = nothing\nto::Any = nothing\n\nSame deal as homs, but for attributes.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.Schemas.attrtypes","page":"Library Reference","title":"ACSets.Schemas.attrtypes","text":"Parameters:\n\ns::Schema{Name}\n\nReturns an iterable of the names of the attrtypes for this schema.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.Schemas.homs","page":"Library Reference","title":"ACSets.Schemas.homs","text":"Parameters:\n\ns::Schema{Name}\n\nNamed Parameters:\n\njust_names::Bool=false\nfrom::Any = nothing\nto::Any = nothing\n\nDefaults to returning an iterable of tuples (f,x,y) where f is the name of a homomorphism and x and y are its domain and codomain respectively.\n\nIf just_names is true, then it just returns the fs.\n\nIf from is not nothing then it should be either an object or an iterable of objects; this then filters to only morphisms that have domain in from. Mutatis mutandis for to.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.Schemas.objects","page":"Library Reference","title":"ACSets.Schemas.objects","text":"Parameters:\n\ns::Schema{Name}\n\nReturns an iterable of the names of the objects for this schema.\n\n\n\n\n\n","category":"function"},{"location":"api/#ACSets.Schemas.types","page":"Library Reference","title":"ACSets.Schemas.types","text":"Returns objects and attrtypes.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicInterfaces.codom","page":"Library Reference","title":"AlgebraicInterfaces.codom","text":"Parameters:\n\ns::Schema{Name}\nf::Name\n\nNamed Parameters:\n\nfrom::Any = nothing\n\nSame deal as dom, but for codomains.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicInterfaces.dom","page":"Library Reference","title":"AlgebraicInterfaces.dom","text":"Parameters:\n\ns::Schema{Name}\nf::Name\n\nNamed Parameters:\n\nto::Any = nothing\n\nIf to is nothing, then this returns the domain of the unique morphism with name f, and errors otherwise. If to is not nothing, then it should be either an object/attrtype or an iterable of objects/attrtypes, and this should return the domain of the unique morphism with codomain in to.\n\n\n\n\n\n","category":"function"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"EditURL = \"../../literate/ADTs.jl\"","category":"page"},{"location":"generated/ADTs/#Specifying-acsets-using-Algebraic-Data-Types","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"","category":"section"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"ACSets are an extremely flexible data representation that can store anything you can put in a database. But in order to construct them, you might want something that feels more like a custom programming language. The Graphviz software comes with a custom language called dot files for specifying the data of a graph that Graphviz will draw. In order to make implementing these linguisting interfaces easier, ACSets.jl supports an Algebraic Data Types approach to specification of ACSets.","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"using ACSets, ACSets.ADTs\nusing MLStyle\nusing Test\nimport ACSets.ADTs: symb2string","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"Our schema will be labeled graphs. These are graphs with vertex labels.","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"SchLabeledGraph = BasicSchema([:E,:V], [(:src,:E,:V),(:tgt,:E,:V)],\n                          [:L], [(:label,:V,:L)])\n\n@acset_type LabeledGraph(SchLabeledGraph, index=[:src,:tgt])","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"The basic principle is a nested expression syntax for specifying the ACSet.","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"s = Statement(:E, [Value(2), Value(3)])","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"You can extract information from an expression with pattern matching from MLStyle.jl","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"get_table(s) = @match s begin\n    Statement(t, e) => t\n    _ => nothing\nend\nget_arg1(s) = @match s begin\n    Statement(t, e) => e[1]\nend\n\n@test get_table(s) == :E\n@test get_arg1(s) == Value(2)","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"These statements can be grouped together into a list an tagged with the type of ACSet you want to make.","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"gspec = ACSetSpec(\n    :(LabeledGraph{Symbol}),\n    [\n        Statement(:V, [Kwarg(:label, Value(:a))])\n        Statement(:V, [Kwarg(:label, Value(:b))])\n        Statement(:V, [Kwarg(:label, Value(:c))])\n        Statement(:E, [Value(1), Value(3)])\n        Statement(:E, [Value(2), Value(3)])\n    ]\n)","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"These expressions can be serialized as strings:","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"sprint(show, gspec)","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"Or as Julia code:","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"generate_expr(gspec)","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"From the ACSetSpec you can construct the ACSet that it specifies.","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"gspec = ACSetSpec(\n    :(LabeledGraph{Symbol}),\n    [\n        Statement(:V, [Kwarg(:label, Value(:a))])\n        Statement(:V, [Kwarg(:label, Value(:b))])\n        Statement(:V, [Kwarg(:label, Value(:c))])\n        Statement(:E, [Kwarg(:src, Value(1)), Kwarg(:tgt, Value(3))])\n        Statement(:E, [Kwarg(:src, Value(2)), Kwarg(:tgt, Value(3))])\n    ]\n)\ng = construct(LabeledGraph{Symbol}, gspec)","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"There is an embedding of ACSetSpec into Expr:","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"hspec = acsetspec(:(LabeledGraph{Symbol}),quote\n    V(label=a)\n    V(label=b)\n    V(label=c)\n    E(src=1,tgt=3)\n    E(src=2,tgt=3)\nend\n)","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"The acsetspec function is a good example of embedding your custom language into Julia syntax That save you the trouble of writing your own lexer and parser for your custom language.","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"construct(LabeledGraph{Symbol}, hspec) == construct(LabeledGraph{Symbol}, gspec)","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"You can export your specification to a dictionary and put that dictionary into a JSON document this gives you a nice way of serializing the ACSet that is machine readable and row oriented. The ACSet serialization is by column oriented which might be inconvenient for your consumers.","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"to_dict(gspec)","category":"page"},{"location":"#ACSets.jl","page":"ACSets.jl","title":"ACSets.jl","text":"","category":"section"},{"location":"","page":"ACSets.jl","title":"ACSets.jl","text":"CurrentModule = ACSets","category":"page"},{"location":"","page":"ACSets.jl","title":"ACSets.jl","text":"Acsets (\"attributed C-sets\") are a family of data structures generalizing both graphs and data frames. They are an efficient in-memory implementation of a category-theoretic formalism for relational databases.","category":"page"},{"location":"","page":"ACSets.jl","title":"ACSets.jl","text":"ACSets.jl is a lightweight package that provides","category":"page"},{"location":"","page":"ACSets.jl","title":"ACSets.jl","text":"data structures for acset schemas, acsets, and tabular columns\nserialization of acset schemas and acsets","category":"page"},{"location":"","page":"ACSets.jl","title":"ACSets.jl","text":"Catlab.jl extends this package to offer many more features, beginning with homomorphisms between acsets and including limits and colimits of acsets, functorial data migration, and automated homomorphism finding. AlgebraicRewriting.jl goes further still to provide declarative rewriting for acsets.","category":"page"},{"location":"#Citation","page":"ACSets.jl","title":"Citation","text":"","category":"section"},{"location":"","page":"ACSets.jl","title":"ACSets.jl","text":"The ideas behind this package are described in the paper:","category":"page"},{"location":"","page":"ACSets.jl","title":"ACSets.jl","text":"Patterson, Lynch, Fairbanks. Categorical data structures for technical computing. Compositionality 4, 5 (2022). arXiv:2106.04703. DOI:10.32408/compositionality-4-5.","category":"page"},{"location":"ADTs/#Library-Reference","page":"Specification Language","title":"Library Reference","text":"","category":"section"},{"location":"ADTs/","page":"Specification Language","title":"Specification Language","text":"The ACSet Specification module with ADTs. This module is not rexported as the function names have not fully stabilized.","category":"page"},{"location":"ADTs/","page":"Specification Language","title":"Specification Language","text":"Modules = [ACSets.ADTs]","category":"page"},{"location":"ADTs/#ACSets.ADTs.acsetspec-Tuple{Any, Any}","page":"Specification Language","title":"ACSets.ADTs.acsetspec","text":"acsetspec(head::Symbol, body::Expr)\n\nprocesses a Julia Expr specifying the ACSet construction into a the ADT representation. Approximate inverse to show\n\n\n\n\n\n","category":"method"},{"location":"ADTs/#ACSets.ADTs.construct-Tuple{Type, ACSets.ADTs.ACSetSpec}","page":"Specification Language","title":"ACSets.ADTs.construct","text":"construct(T::Type, sp::ACSetSpec)\n\ninvoke the constructor and build the acset by adding parts.\n\n\n\n\n\n","category":"method"},{"location":"ADTs/#ACSets.ADTs.generate_expr-Tuple{ACSets.ADTs.Args}","page":"Specification Language","title":"ACSets.ADTs.generate_expr","text":"generate_expr(s::ACSetSpec)\n\ncreates a julia Expr that will generate the specified ACSet. \n\n\n\n\n\n","category":"method"},{"location":"ADTs/#ACSets.ADTs.label2index-Tuple{ACSets.ADTs.ACSetSpec}","page":"Specification Language","title":"ACSets.ADTs.label2index","text":"label2index(s::ACSetSpec)\n\nreplace symbolic identifiers in an ACSet spec with the indices that have that label. This function assumes that all labels are globally unique across tables.  So prefix them with the table name if you want scopes. It also assumes that you don't have any other attributes of type symbol, so use strings instead.\n\n\n\n\n\n","category":"method"},{"location":"ADTs/#ACSets.ADTs.to_dict-Tuple{Any}","page":"Specification Language","title":"ACSets.ADTs.to_dict","text":"to_dict(s::ACSetSpec)\n\ngenerates a dictionary representation the ACSetSpec (or any sub-term). This dict should be serializable with JSON.json.\n\n\n\n\n\n","category":"method"},{"location":"ADTs/#Base.show-Tuple{IO, ACSets.ADTs.AbstractACSetSpec}","page":"Specification Language","title":"Base.show","text":"show(io::IO, s::AbstractACSetSpec)\n\ngenerates a human readable string of the ACSetSpec (or any sub-term).\n\n\n\n\n\n","category":"method"}]
}
