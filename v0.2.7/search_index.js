var documenterSearchIndex = {"docs":
[{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"EditURL = \"../../literate/json_serialization.jl\"","category":"page"},{"location":"generated/json_serialization/#Serializing-acsets-as-JSON","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"","category":"section"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"Catlab supports the serialization of attributed C-sets (acsets) into JSON with their schemas. This functionality should allow you to interoperate with database representations in other languages by serializing both the data and the type into a network interoperability layer.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"import JSON, JSONSchema\n\nusing ACSets","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"You can interact with the schema representation using JSON Schema with the write_json_acset_schema and read_json_acset_schema functions.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"function roundtrip_json_acset_schema(schema)\n  mktempdir() do dir\n    path = joinpath(dir, \"schema.json\")\n    write_json_acset_schema(schema, path)\n    read_json_acset_schema(path)\n  end\nend","category":"page"},{"location":"generated/json_serialization/#The-JSONSchema-for-Schemas","page":"Serializing acsets as JSON","title":"The JSONSchema for Schemas","text":"","category":"section"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"The following code shows how to view the schema for storing schemas. You can see that this data is encoded in the standardized JSONSchema format, which is a generic way of representing data structures that are serialized to JSON. Notice that there are properties for Homs and Obs. The Homs have fields like name, dom, and codom. The Obs just have a name. AttrTypes are like Obs, but they store the name of the type that the attribute can have. In Julia, the Schemas are parametric in the AttrTypes so that uses can set those types at instance creation time. Attrs are the names of columns that point into the AttrTypes.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"json_schema = JSONSchema.Schema(acset_schema_json_schema())\nJSON.print(json_schema, 2)","category":"page"},{"location":"generated/json_serialization/#Example-1:-Discrete-Dynamical-Systems","page":"Serializing acsets as JSON","title":"Example 1: Discrete Dynamical Systems","text":"","category":"section"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"Here is an example of an ACSet schema for Discrete Dynamical Systems. A DDS is just a set X whose elements we call states, and a function next, which take the current state and gives you the next state. Such systems are used to model processes that occur autonomously and are the simplest possible dynamical system.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"SchDDS = BasicSchema([:X], [(:next,:X,:X)])\n\nJSON.print(generate_json_acset_schema(SchDDS), 2)","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"LabeledDDS are a variation on DDS where the states can have symbolic names. In Catlab, every element of an object has to be identified by its integer row number. This comes out of a tradition in database design where every table has a natural number primary key. In mathematics, we often want to think of the state space not as a set of integers, but as an arbitrary set. In Catlab, we call that set the Labels and use a label attribute to implement the mapping of state numbers to state labels. This way the underlying database implementation can still be designed aroung natural number primary keys, but the user can use symbolic labels. Note also that this shows the schema inheritance. We state that a SchLabeledDDS inherits from SchDDS by adding a label attribute of type Label.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"SchLabeledDDS = BasicSchema([:X], [(:next,:X,:X)],\n                            [:Label], [(:label,:X,:Label)])\n\nJSON.print(generate_json_acset_schema(SchLabeledDDS), 2)","category":"page"},{"location":"generated/json_serialization/#Example-2:-Labeled-DDS","page":"Serializing acsets as JSON","title":"Example 2: Labeled DDS","text":"","category":"section"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"With the LabeledDDS, we will create an instance by specifying data that fits the schema. Then we will create the JSON output to show how it is encoded. The JSON encoded schema above tells you how to read the JSON encoded data below. You can see that the LabeledDDS will have a set for X with a Hom for next and an attribute for label. Thus we can expect to see the JSON encoding of a single table database below:     1. The first level of JSON is keyed by the table names     2. Each Table is an array of rows     3. Each row is an object keyed by fields. This is the simplest way to put a relational database in a JSON document. It is a little redundant, because the field names are repeated for each row. But that makes it easy to emit and easy to parse. If this becomes a problem, we can upgrade to a more efficient representation by writing more sophisticated parsers. Something like https://github.com/JuliaIO/MsgPack.jl would be appropriate.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"@acset_type LabeledDDS(SchLabeledDDS, index=[:next, :label])\n\nldds = LabeledDDS{Int}()\nadd_parts!(ldds, :X, 4, next=[2,3,4,1], label=[100, 101, 102, 103])\nJSON.print(generate_json_acset(ldds),2)","category":"page"},{"location":"generated/json_serialization/#Example-3:-Graphs","page":"Serializing acsets as JSON","title":"Example 3: Graphs","text":"","category":"section"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"Relational databases are great, because they are capable of representing almost anything that can be stored on a computer. We move up to graphs, which is a nice data structure you have probably seen before. Notably, graphs have two tables, one for edges and one for vertices. These are the category theorist's graph, which means that they support multiple parallel edges and self-loops.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"# Syntax available in Catlab:\n# @present SchGraph(FreeSchema) begin\n#   V::Ob\n#   E::Ob\n#   src::Hom(E,V)\n#   tgt::Hom(E,V)\n# end\n\nSchGraph = BasicSchema([:V,:E], [(:src,:E,:V),(:tgt,:E,:V)])\n\nJSON.print(generate_json_acset_schema(SchGraph), 2)","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"An example graph with 4 vertices and 2 edges.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"@acset_type Graph(SchGraph, index=[:src, :tgt])\n\ng = Graph()\nadd_parts!(g, :V, 4)\nadd_parts!(g, :E, 2, src=[1,2], tgt=[2,3])","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"Note that the vertices are listed out in a somewhat silly way. They are given as a table with no columns, so they show up in the JSON as a bunch of empty objects. This is for consistency with our next example.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"JSON.print(generate_json_acset(g), 2)","category":"page"},{"location":"generated/json_serialization/#Example-4:-Vertex-and-Edge-Labeled-Graph-Graph-Schema","page":"Serializing acsets as JSON","title":"Example 4: Vertex and Edge Labeled Graph Graph Schema","text":"","category":"section"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"You can extend schemas by adding more tables and columns. This inheritance is flattened when you serialize to JSON, but could be encoded in a future version.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"# Syntax available in Catlab:\n# @present SchVELabeledGraph <: SchGraph begin\n#    Label::AttrType\n#    vlabel::Attr(V,Label)\n#    elabel::Attr(E,Label)\n# end\n\nSchVELabeledGraph = BasicSchema([:V,:E], [(:src,:E,:V),(:tgt,:E,:V)],\n  [:Label], [(:vlabel,:V,:Label),(:elabel,:E,:Label)])\n\nJSON.print(generate_json_acset_schema(SchVELabeledGraph), 2)","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"An example labeled graph using symbols for the vertex and edge names. Note that you can use unicode symbols in Julia.","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"@acset_type VELabeledGraph(SchVELabeledGraph, index=[:src,:tgt])\n\nlg = VELabeledGraph{Symbol}()\nadd_parts!(lg, :V, 4, vlabel=[:a, :b, :c, :d])\nadd_parts!(lg, :E, 2, src=[1,2], tgt=[2,3], elabel=[:e₁, :e₂])","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"This Graph is represented by the following JSON. Now you can see that the vertices have their vlabels","category":"page"},{"location":"generated/json_serialization/","page":"Serializing acsets as JSON","title":"Serializing acsets as JSON","text":"JSON.print(generate_json_acset(lg), 2)","category":"page"},{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ACSets]","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"EditURL = \"../../literate/ADTs.jl\"","category":"page"},{"location":"generated/ADTs/#Specifying-acsets-using-Algebraic-Data-Types","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"","category":"section"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"ACSets are an extremely flexible data representation that can store anything you can put in a database. But in order to construct them, you might want something that feels more like a custom programming language. The Graphviz software comes with a custom language called dot files for specifying the data of a graph that Graphviz will draw. In order to make implementing these linguisting interfaces easier, ACSets.jl supports an Algebraic Data Types approach to specification of ACSets.","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"using ACSets, ACSets.ADTs\nusing MLStyle\nusing Test\nimport ACSets.ADTs: symb2string","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"Our schema will be labeled graphs. These are graphs with vertex labels.","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"SchLabeledGraph = BasicSchema([:E,:V], [(:src,:E,:V),(:tgt,:E,:V)],\n                          [:L], [(:label,:V,:L)])\n\n@acset_type LabeledGraph(SchLabeledGraph, index=[:src,:tgt])","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"The basic principle is a nested expression syntax for specifying the ACSet.","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"s = Statement(:E, [Value(2), Value(3)])","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"You can extract information from an expression with pattern matching from MLStyle.jl","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"get_table(s) = @match s begin\n    Statement(t, e) => t\n    _ => nothing\nend\nget_arg1(s) = @match s begin\n    Statement(t, e) => e[1]\nend\n\n@test get_table(s) == :E\n@test get_arg1(s) == Value(2)","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"These statements can be grouped together into a list an tagged with the type of ACSet you want to make.","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"gspec = ACSetSpec(\n    :(LabeledGraph{Symbol}),\n    [\n        Statement(:V, [Kwarg(:label, Value(:a))])\n        Statement(:V, [Kwarg(:label, Value(:b))])\n        Statement(:V, [Kwarg(:label, Value(:c))])\n        Statement(:E, [Value(1), Value(3)])\n        Statement(:E, [Value(2), Value(3)])\n    ]\n)","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"These expressions can be serialized as strings:","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"sprint(show, gspec)","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"Or as Julia code:","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"generate_expr(gspec)","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"From the ACSetSpec you can construct the ACSet that it specifies.","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"gspec = ACSetSpec(\n    :(LabeledGraph{Symbol}),\n    [\n        Statement(:V, [Kwarg(:label, Value(:a))])\n        Statement(:V, [Kwarg(:label, Value(:b))])\n        Statement(:V, [Kwarg(:label, Value(:c))])\n        Statement(:E, [Kwarg(:src, Value(1)), Kwarg(:tgt, Value(3))])\n        Statement(:E, [Kwarg(:src, Value(2)), Kwarg(:tgt, Value(3))])\n    ]\n)\ng = construct(LabeledGraph{Symbol}, gspec)","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"There is an embedding of ACSetSpec into Expr:","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"hspec = acsetspec(:(LabeledGraph{Symbol}),quote\n    V(label=a)\n    V(label=b)\n    V(label=c)\n    E(src=1,tgt=3)\n    E(src=2,tgt=3)\nend\n)","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"The acsetspec function is a good example of embedding your custom language into Julia syntax That save you the trouble of writing your own lexer and parser for your custom language.","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"construct(LabeledGraph{Symbol}, hspec) == construct(LabeledGraph{Symbol}, gspec)","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"You can export your specification to a dictionary and put that dictionary into a JSON document this gives you a nice way of serializing the ACSet that is machine readable and row oriented. The ACSet serialization is by column oriented which might be inconvenient for your consumers.","category":"page"},{"location":"generated/ADTs/","page":"Specifying acsets using Algebraic Data Types","title":"Specifying acsets using Algebraic Data Types","text":"to_dict(gspec)","category":"page"},{"location":"#ACSets.jl","page":"ACSets.jl","title":"ACSets.jl","text":"","category":"section"},{"location":"","page":"ACSets.jl","title":"ACSets.jl","text":"CurrentModule = ACSets","category":"page"},{"location":"","page":"ACSets.jl","title":"ACSets.jl","text":"Acsets (\"attributed C-sets\") are a family of data structures generalizing both graphs and data frames. They are an efficient in-memory implementation of a category-theoretic formalism for relational databases.","category":"page"},{"location":"","page":"ACSets.jl","title":"ACSets.jl","text":"ACSets.jl is a lightweight package that provides","category":"page"},{"location":"","page":"ACSets.jl","title":"ACSets.jl","text":"data structures for acset schemas, acsets, and tabular columns\nserialization of acset schemas and acsets","category":"page"},{"location":"","page":"ACSets.jl","title":"ACSets.jl","text":"Catlab.jl extends this package to offer many more features, beginning with homomorphisms between acsets and including limits and colimits of acsets, functorial data migration, and automated homomorphism finding. AlgebraicRewriting.jl goes further still to provide declarative rewriting for acsets.","category":"page"},{"location":"#Citation","page":"ACSets.jl","title":"Citation","text":"","category":"section"},{"location":"","page":"ACSets.jl","title":"ACSets.jl","text":"The ideas behind this package are described in the paper:","category":"page"},{"location":"","page":"ACSets.jl","title":"ACSets.jl","text":"Patterson, Lynch, Fairbanks. Categorical data structures for technical computing. Compositionality 4, 5 (2022). arXiv:2106.04703. DOI:10.32408/compositionality-4-5.","category":"page"},{"location":"ADTs/#Library-Reference","page":"Specification Language","title":"Library Reference","text":"","category":"section"},{"location":"ADTs/","page":"Specification Language","title":"Specification Language","text":"The ACSet Specification module with ADTs. This module is not rexported as the function names have not fully stabilized.","category":"page"},{"location":"ADTs/","page":"Specification Language","title":"Specification Language","text":"Modules = [ACSets.ADTs]","category":"page"},{"location":"ADTs/#ACSets.ADTs.acsetspec-Tuple{Any, Any}","page":"Specification Language","title":"ACSets.ADTs.acsetspec","text":"acsetspec(head::Symbol, body::Expr)\n\nprocesses a Julia Expr specifying the ACSet construction into a the ADT representation. Approximate inverse to show\n\n\n\n\n\n","category":"method"},{"location":"ADTs/#ACSets.ADTs.construct-Tuple{Type, ACSets.ADTs.ACSetSpec}","page":"Specification Language","title":"ACSets.ADTs.construct","text":"construct(T::Type, sp::ACSetSpec)\n\ninvoke the constructor and build the acset by adding parts.\n\n\n\n\n\n","category":"method"},{"location":"ADTs/#ACSets.ADTs.generate_expr-Tuple{ACSets.ADTs.Args}","page":"Specification Language","title":"ACSets.ADTs.generate_expr","text":"generate_expr(s::ACSetSpec)\n\ncreates a julia Expr that will generate_expr the specified ACSet. \n\n\n\n\n\n","category":"method"},{"location":"ADTs/#ACSets.ADTs.label2index-Tuple{ACSets.ADTs.ACSetSpec}","page":"Specification Language","title":"ACSets.ADTs.label2index","text":"label2index(s::ACSetSpec)\n\nreplace symbolic identifiers in an ACSet spec with the indices that have that label. This function assumes that all labels are globally unique across tables.  So prefix them with the table name if you want scopes. It also assumes that you don't have any other attributes of type symbol, so use strings instead.\n\n\n\n\n\n","category":"method"},{"location":"ADTs/#ACSets.ADTs.to_dict-Tuple{Any}","page":"Specification Language","title":"ACSets.ADTs.to_dict","text":"to_dict(s::ACSetSpec)\n\ngenerates a dictionary representation the ACSetSpec (or any sub-term). This dict should be serializable with JSON.json.\n\n\n\n\n\n","category":"method"},{"location":"ADTs/#Base.show-Tuple{IO, ACSets.ADTs.AbstractACSetSpec}","page":"Specification Language","title":"Base.show","text":"show(io::IO, s::AbstractACSetSpec)\n\ngenerates a human readable string of the ACSetSpec (or any sub-term).\n\n\n\n\n\n","category":"method"}]
}
